# ICS HW5

## T1

### 问题
- 执行完`TRAP x22`之后会出现未定义行为.
- `TRAP x23`会从键盘读取一个字符，但是`LEA R0, MESSAGE`会覆盖这个字符，无效操作.
### 解决方法
1.在`TRAP x22`和`MESSAGE .STRINGZ "Program reporting"`之间添加一条`TRAP x25`.
2.在`TRAP x22`之后添加一个`BR`指令，跳转到`HALT`.
```
        LEA R0, MESSAGE
        TRAP x22        ; PUTS
        BRnzp DONE      ; Go to DONE
MESSAGE .STRINGZ "Program reporting"
DONE    TRAP x25        ;
```
## T2
(1)因为`HALT`其实是`TRAP 0x25`，`PC`会跳转到操作系统`HALT`例程中，而这个过程会操作寄存器并修改其中的值，所以会导致结果和预期不符。

(2)会。让`PC`在`HALT`例程中不断循环，实现停机的效果。
## T3
- 触发方式不同：`TRAP`是由指令自主触发，而中断是硬件或者外设触发的。
- 用途不同：中断用于响应外部事件，比如键盘的输入，`TRAP`则共程序主动调用。
- 时序不同：`TRAP`和时钟周期是对齐的，而中断则不是，也就是异步的。
## T4
(1) 系统空间是用来存储操作系统的空间，包括系统文件和系统程序等数据。

(2) 用户空间是分配给用户的空间，用来存放和运行用户的程序和数据等。

(3) 用户模式不可访问系统空间。

(4) `ACV`是`Access Control Violation`，当程序访问无法访问的地址的时候就会触发。

(5) 虚拟地址有效；有对应权限；是否有特权。

(6) `TRAP`、外部中断、异常。
## T5
```asm
      .ORIG x3000
A     LD  R0, E
      LEA R7, E
B     .FILL x1021
      ADD R2, R0, #0
      LD  R1, D
      LD  R3, B
      ADD R3, R1, R3
      ST  R3, C
C     .BLKW 1
      RET
D     .STRINGZ "!"
E     LD R1, A
F     ADD R0, R0, R1
      HALT
      .END
```

```
假设代码从 x3000 开始。
x3000 加载标签E的内容到R0中，即R0 = 0010 001 111110100 = x23F4
x3001 加载E的地址到R7中，即R7 = x300B
x3002 在标签B的地址存储值x1021，即x3002->x1021
x3003 R2 = R0 + 0，即R2 = x23F4
x3004 加载标签D的内容到R1，即R1 = 
; 5. (x3004): LD R1, D
;    - 加载标签 D (地址 x300A) 处的内容到 R1。
;    - D 是 .STRINGZ "!"，它在 x300A 存入 '!' 的 ASCII 码，即 x0021。
;    - 执行后: R1 = x0021

; 6. (x3005): LD R3, B
;    - 加载标签 B (地址 x3002) 处的内容到 R3。
;    - 执行后: R3 = x1021

; 7. (x3006): ADD R3, R1, R3
;    - R3 = R1 + R3 = x0021 + x1021
;    - 执行后: R3 = x1042

; 8. (x3007): ST R3, C
;    - 将 R3 的值存储到标签 C (地址 x3008) 处。
;    - 执行后: MEM[x3008] = x1042

; 9. C (x3008): .BLKW 1
;    - 此处原先是保留空间，现在被 ST 指令写入了 x1042。

; 10. (x3009): RET
;    - 跳转到 R7 中的地址，即 JMP R7。
;    - 程序跳转到 x300C。

; 11. E (x300C): LD R1, A
;    - 加载标签 A (地址 x3000) 处的内容到 R1。
;    - 地址 x3000 的内容是指令 `LD R0, E` 的机器码。
;    - `LD R0, E` 的机器码计算：
;      - LD 操作码: 0010
;      - DR (R0): 000
;      - PCoffset (从 x3001 到 x300C): x300C - x3001 = 11 = 000001011
;      - 机器码: 0010 000 000001011 = x200B (修正：PCoffset 是相对于 PC+1 的，所以是 x300C - (x3000+1) = x000B)
;      - 让我们重新计算 `LD R0, E` 的机器码：PC at x3000, PC+1=x3001. E is at x300C. Offset = x300C - x3001 = x000B.
;      - 机器码: 0010 000 000001011 = x200B.
;    - 所以，`LD R1, A` 加载的是 `LD R0, E` 的机器码。
;    - 等等，我在第一步的分析中，加载到 R0 的是 `LD R1, A` 的机器码，这里加载到 R1 的是 `LD R0, E` 的机器码。让我们重新确认。
;    - 步骤1: `LD R0, E` -> R0 = MEM[E] = MEM[x300C] = `LD R1, A` 的机器码 = x22F3。这是正确的。
;    - 步骤11: `LD R1, A` -> R1 = MEM[A] = MEM[x3000] = `LD R0, E` 的机器码。
;      - `LD R0, E` 的机器码计算: PC=x3000, PC+1=x3001. E at x300C. Offset = x300C - x3001 = x000B.
;      - 机器码: 0010 000 000001011 = x200B.
;    - 执行后: R1 = x200B

; 12. F (x300D): ADD R0, R0, R1
;    - 这是最后一步。
;    - R0 = R0 + R1
;    - 当前 R0 = x22F3 (来自步骤1)
;    - 当前 R1 = x200B (来自步骤11)
;    - R0 = x22F3 + x200B
;      ```
;        x22F3
;      + x200B
;      -------
;        x42FE
;      ```
;    - 执行后: R0 = x42FE

; 最终答案: 在 F 处执行后，R0 的值为 x42FE。
````